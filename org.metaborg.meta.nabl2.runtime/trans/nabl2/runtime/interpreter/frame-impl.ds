module nabl2/runtime/interpreter/frame

imports
  nabl2/runtime/interpreter/frame-api

// FIXME: All named arrows should be meta-functions, once we get better support for overloaded default arrows.

signature

  constructors
    Addr : Frame * Occurrence -> Addr

  sorts FrameContainer constructors
    FC_ : Scope * Map(Label, Map(Scope, Frame)) * Map(Occurrence, Val) -> Frame 
    
  constructors
    F_ : Int -> Frame {implicit}
    H_ : Map(Frame, Frame) -> Heap {implicit}

//////////////////////////////
// VANILLA FRAMES AND HEAPS //
//////////////////////////////

rules

  // Operations on heap
  
  initHeap(_) --> H_({}).

  // Operations on frames

  initFrame(s, ks, slots) :: H H_(x) --> ff :: H { ff |--> FC_(s, ks, slots), x }
  where
    fresh => ff.
 
  H H_(x) |- scopeOf(f) --> s
  where
    x[f] => FC_(s, _, _).
  
  // Dynamic address lookup  
  F f |- lookup([D(_, d)]) --> Addr(f, d).

  H h, F f1 |- lookup([E(s, l)|p]) --> Addr(f3, d)
  where
    H h |- linksOf(f1) --> ks;
    ks[l][s] => f2;
    H h, F f2 |- lookup(p) --> Addr(f3, d).
 
  // Fetching and mutating slot values
    
  H h |- get(Addr(f', d)) --> v
  where
    H h |- slotsOf(f') --> slots;
    slots[d] => v.

  set(Addr(f, d), v) :: H H_(x) --> v :: H {f |--> FC_(s, ks, {d |--> v, slots}), x}
  where
    x[f] => FC_(s, ks, slots).
  

rules
  
  H H_(x) |- linksOf(f) --> ks
  where
    x[f] => FC_(_, ks, _).
    
  H H_(x) |- slotsOf(f) --> slots
  where
    x[f] => FC_(_, _, slots).

//////////////////////////////
// DEFAULT FRAMES AND HEAPS //
//////////////////////////////

signature // Utility function
  
  arrows
    DefaultSlots(List(Occurrence)) --> Map(Occurrence, Val)

rules // Utility function

  DefaultSlots([]) --> {}.

  DefaultSlots([d|ds]) --> { d |--> v, slots }
  where
    d -typeOf-> t;
    default(t) --> v;
    DefaultSlots(ds) --> slots.

rules // initDefault

  initDefault(s, ks) :: H H_(x) --> ff :: H { ff |--> FC_(s, ks, slots), x }
  where
    fresh => ff;
    s -declsOf-> ds;
    DefaultSlots(ds) --> slots.