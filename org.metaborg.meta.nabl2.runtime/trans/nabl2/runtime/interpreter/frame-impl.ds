module nabl2/runtime/interpreter/frame

imports
  nabl2/runtime/interpreter/frame-api

// FIXME: All named arrows should be meta-functions, once we get better support for overloaded default arrows.

signature

  constructors
    Addr : Frame * Occurrence -> Addr

  sorts FrameContainer constructors
    FC_ : Scope * Map(Label, Map(Scope, Frame)) * Map(Occurrence, Val) -> Frame 
    
  constructors
    F_ : Int -> Frame // {implicit}
    H_ : Map(Frame, Frame) -> Heap // {implicit}

//////////////////////////////
// VANILLA FRAMES AND HEAPS //
//////////////////////////////

rules

  // Operations on heap
  
  initHeap(_) --> H_({}).

  // Operations on frames

  initFrame(s, ks, slots) :: H H_(x) --> ff :: H H_({ ff |--> FC_(s, ks, slots), x })
  where
    F_(fresh) => ff.
 
  H H_(x) |- scopeOf(f) --> s
  where
    x[f] => FC_(s, _, _).
  
  // Dynamic address lookup  
  F f |- lookup([D(_, d)]) --> Addr(f, d).

  H h, F f1 |- lookup([E(s, l)|p]) --> Addr(f3, d)
  where
    H h |- linksOf(f1) --> ks;
    ks[l][s] => f2;
    H h, F f2 |- lookup(p) --> Addr(f3, d).
 
  // Fetching and mutating slot values
    
  H h |- get(Addr(f', d)) --> v
  where
    H h |- slotsOf(f') --> slots;
    slots[d] => v.

  set(Addr(f, d), v) :: H H_(x) --> v :: H H_({f |--> FC_(s, ks, {d |--> v, slots}), x})
  where
    x[f] => FC_(s, ks, slots).
  
  mkAddr(f, d) --> Addr(f, d).

rules
  
  H H_(x) |- linksOf(f) --> ks
  where
    x[f] => FC_(_, ks, _).
    
  H H_(x) |- slotsOf(f) --> slots
  where
    x[f] => FC_(_, _, slots).

//////////////////////////////
// DEFAULT FRAMES AND HEAPS //
//////////////////////////////

signature // Utility function
  
  arrows
    DefaultSlots(List(Occurrence)) --> Map(Occurrence, Val)

rules // Utility function

  DefaultSlots([]) --> {}.

  DefaultSlots([d|ds]) --> { d |--> v, slots }
  where
    d -typeOf-> t;
    default(t) --> v;
    DefaultSlots(ds) --> slots.

rules // initDefault

  initDefault(s, ks) :: H H_(x) --> ff :: H H_({ ff |--> FC_(s, ks, slots), x })
  where
    F_(fresh) => ff;
    s -declsOf-> ds;
    DefaultSlots(ds) --> slots.

signature // initEager helpers
  
  arrows
    initEagerEdges(List((Label * List(Scope)))) :: H --> Map(Label, Map(Scope, Frame)) :: H
    initEagerEdge(List(Scope)) :: H --> Map(Scope, Frame) :: H

rules // initEager takes a scope and recursively traverses its edges to construct frame links

  initEager(s) --> initDefault(s, links)
  where
    s -edgesOf-> es;
    initEagerEdges(es) --> links.
    
  initEagerEdges([]) --> {}.
  
  initEagerEdges([(l, ss)|edges]) -->
    { l |--> link, initEagerEdges(edges) }
  where
    initEagerEdge(ss) --> link.

  initEagerEdge([]) --> {}.
  
  initEagerEdge([s|ss]) --> { s |--> F, link }
  where
    initEager(s) --> F;
    initEagerEdge(ss) --> link.
