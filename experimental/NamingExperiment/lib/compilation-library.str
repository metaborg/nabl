module lib/compilation-library

imports
  libstratego-lib
  lib/editor-common.generated
  lib/index-library
  lib/analysis-library
  
rules // Extension points
    
  // Should desugar given ast.
  index-desugar-ast = fail
    
  // Should compile given analysed ast.
  index-compile-ast(|file, subfile, project-path) = fail
  
rules // Compilation
  
  /**
   * Schedules compilation of all files that have changed since the last compilation.
   */
  index-schedule-compilation:
    _ -> None()
    with
      queue-strategy(|"index-compilation", "Compiling files")
  
  /** @internal */
  index-compilation:
    language -> None()
    with
      // Init
      project-path := <project-path>;
      index-setup(|language, [project-path], ".")
    with
      // Determine the files to compile by looking at changed files
      diffs         := <analyze-get-compilediffs>;
      files         := <map(index-compilation-restore-read-file)> diffs;
      filteredFiles := <make-set> <remove-all(index-compilation-filter-file)> files;
      
      // Clean compile time reads
      <filter(index-compilation-clean-reads)> filteredFiles;
      
      // Set total work units to number of files to compile for visual indication
      <set-total-work-units> <length> filteredFiles;
      
      // Compile the files
      <filter(index-compilation-file(|language, project-path); complete-work-unit)> filteredFiles

  /** @internal */
  index-compilation-file(|language, project-path):
    (file, subfile) -> None()
    with
      // Parse and analyze ast.
      ast                              := <parse-file> file;
      ast'                             := <try(index-desugar-ast)> ast;
      Results(ast'', _, _, _, _, _, _) := <analyze-top-internal(|Compile(), language, file)> (ast', file, project-path)
    with
      {| Index-ReadSet:
        readSet := <new-iset>;
        rules(Index-ReadSet: _ -> readSet);
        
        // Compile file
        <index-compile-ast(|file, subfile, project-path)> ast';
        
        // Store compile-time reads.
        reads := <iset-elements> readSet;
        <index-add-all(|<index-compilation-file-tuple> (file, subfile))> reads
      |}

  /** @internal */
  index-compilation-filter-file = 
    ?(<id>, _); (is-test-file <+ index-is-fake-file <+ not(file-exists))
    
rules // On save handling
  
  /**
   * Commits the index to disk and schedules compilation.
   *
   * @see trigger-commit-and-compile
   *
   * @internal
   */
  commit-and-compile:
    language -> None()
    with
      index-commit
    with
      index-schedule-compilation

  /**
   * Triggers commit and compilation, requires target language as current term.
   * Compilation can be delayed by using disable-commit-and-compile. Compilation will be triggered when 
   * enable-commit-and-compile is called.
   */
  trigger-commit-and-compile:
    language -> <id>
    with
      if not(index-is-global-enabled(|"delay-compile")) then
        commit-and-compile
      else
        index-enable-global(|"trigger-compile")
      end
  
  /**
   * Delays commit and compilation until enable-commit-and-compile is called.
   */
  disable-commit-and-compile = index-enable-global(|"delay-compile")
  
  /**
   * Cancels the commit and compilation delay. If commit and compilation was triggered during the delay, it
   * is triggered now.
   */
  enable-commit-and-compile:
    language -> <id>
    with
      if index-is-global-enabled(|"trigger-compile") then
        commit-and-compile
      end;
      index-disable-global(|"delay-compile")
      
/** @internal */
rules // Compile time reads

  index-compilation-restore-read-file:
    (file, subfile) -> (file', subfile)
    with
      file' := <string-replace(|<index-compilation-read-path>, "")> file
      
  index-compilation-clean-reads = 
    ?(file, subfile); index-compilation-file-tuple; index-clear-file
      
  index-compilation-file-tuple:
    (file, subfile) -> ($[[<index-compilation-read-path>]/[file]], subfile)
    
  index-compilation-read-path =
    !"/.internal/reads/compile"
    