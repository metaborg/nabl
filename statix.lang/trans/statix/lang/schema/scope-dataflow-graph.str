module statix/lang/schema/scope-dataflow-graph

imports

  nabl2/api

  signatures/statix/lang/-
  libstratego-aterm

  statix/lang/normalize/util
  statix/lang/generate

signature

  // Structure of Dataflow graph
  sorts SDFGNode constructors
    Variable : Var -> SDFGNode                  // Variable
    PArg     : ConstraintId * int -> SDFGNode   // Predicate argument
    CArg     : SortId       * int -> SDFGNode   // Constructor argument
    RArg     : RelationId   * int -> SDFGNode   // Relation argument

  sorts SDFGEdge constructors
    DEdge    : SDFGNode * SDFGNode -> SDFGEdge  // Directed Edge
    UEdge    : SDFGNode * SDFGNode -> SDFGEdge  // Undirected Edge

rules

  extract-sdfg: spec -> (scope*, edge*, decl*, sdfg-c*)
    with scope*  := <extract-scopes> spec
    with edge*   := <extract-edges> spec
    with decl*   := <extract-decls> spec
    with sdfg-c* := <extract-spec-sdfg> spec

rules

  // Extract all scope graph assertions
  extract-scopes = collect-om(?CNew(<id>)); flatten-list; map(strip-annos)
  extract-edges  = collect-om(CTellEdge(strip-annos, id, strip-annos))
  extract-decls  = collect-om(CTellRel(id, id, strip-annos))

rules

  extract-spec-sdfg = collect-om(extract-rule-sdfg); flatten-list

  extract-rule-sdfg: Rule(name, head, body) -> sdfg-c*
    with sdfg-c* := <conc> (<extract-head-sdfg> head, <extract-body-sdfg> body)

  extract-head-sdfg: C(c-id, args) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-p-arg(|c-id), mk-rev-d-edge)> args

  extract-body-sdfg = collect-om(extract-constraint-sdfg)

  extract-constraint-sdfg: C(c-id, args, _) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-p-arg(|c-id), mk-d-edge)> args

  /* extract-constraint-sdfg: CNew(var) -> sdfg-c*
    with sdfg-c* := [ DEdge(Variable(var), Variable(<term-to-var()> var)) ] */

  /* extract-constraint-sdfg: CTellEdge(src, lbl, tgt) -> sdfg-c*
    with sdfg-c* := [ DEdge(Variable(<term-to-var()> src), src)
                    , DEdge(Variable(<term-to-var()> tgt), tgt)] */

  extract-constraint-sdfg: CTellRel(rel, args, _) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-r-arg(|rel), mk-d-edge)> args

  // FIXME: How about constraints like `MOD(s1) == MOD(s2)`?
  extract-constraint-sdfg: CEqual(v1@Var(_), v2@Var(_), _) -> sdfg-c*
    where <sdfg-is-scope> v1
    with  <sdfg-is-scope> v2
        ; sdfg-c* := [UEdge(Variable(v1), Variable(v2))]

  extract-terms-sdfg(mk-cvar, mk-edge) = map-with-index(extract-term-sdfg(mk-cvar, mk-edge)); flatten-list

  extract-term-sdfg(mk-cvar, mk-edge): e@(i, v@Var(_)) -> <mk-edge> (cvar, Variable(<strip-annos> v))
    where <sdfg-is-scope> v
     with cvar := <mk-cvar> i

  extract-term-sdfg(mk-cvar, mk-edge): (i, v@List(ts)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(\_ -> <mk-cvar> i \, mk-u-edge)> ts

  extract-term-sdfg(mk-cvar, mk-edge): (i, v@ListTail(ts, _)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(\_ -> <mk-cvar> i \, mk-u-edge)> ts

  extract-term-sdfg(mk-cvar, mk-edge): (i, v@Tuple(ts)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-c-arg(|""), mk-u-edge)> ts

  extract-term-sdfg(mk-cvar, mk-edge): (i, v@As(_, t)) -> sdfg-c*
    with sdfg-c* := <extract-term-sdfg(mk-cvar, mk-u-edge)> (i, t)

  extract-term-sdfg(mk-cvar, mk-edge): (i, v@Ascribe(t, _)) -> sdfg-c*
    with sdfg-c* := <extract-term-sdfg(mk-cvar, mk-u-edge)> (i, t)

  extract-term-sdfg(mk-cvar, mk-edge): (i, v@Op(c, ts)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-c-arg(|c), mk-u-edge)> ts

  extract-term-sdfg(mk-cvar, mk-edge): t -> []

rules

  mk-c-arg(|c-id): i -> CArg(c-id, i)
  mk-p-arg(|c-id): i -> PArg(c-id, i)
  mk-r-arg(|r-id): i -> RArg(r-id, i)

  mk-u-edge     : (v1, v2) -> [UEdge(v1, v2)]
  mk-d-edge     : (v1, v2) -> [DEdge(v1, v2)]
  mk-rev-d-edge : (v1, v2) -> [DEdge(v2, v1)]

  sdfg-is-scope = get-annos; fetch-elem(?OfSort(<id>)); ?SCOPE()
