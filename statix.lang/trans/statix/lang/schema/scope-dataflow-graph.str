module statix/lang/schema/scope-dataflow-graph

imports

  nabl2/api

  signatures/statix/lang/-
  libstratego-aterm

  statix/lang/normalize/util
  statix/lang/generate

signature

  // Structure of Dataflow graph
  sorts SDFGNode constructors
    Variable : Var -> SDFGNode                  // Variable
    PArg     : ConstraintId * int -> SDFGNode   // Predicate argument
    CArg     : SortId       * int -> SDFGNode   // Constructor argument
    RArg     : RelationId   * int -> SDFGNode   // Relation argument

  sorts SDFGEdge constructors
    DEdge    : SDFGNode * SDFGNode -> SDFGEdge  // Directed Edge
    UEdge    : SDFGNode * SDFGNode -> SDFGEdge  // Undirected Edge

rules

  extract-sdfg: spec -> (scope*, edge*, decl*, sdfg-c*)
    with scope*  := <extract-scopes> spec
    with edge*   := <extract-edges> spec
    with decl*   := <extract-decls> spec
    with sdfg-c* := <extract-spec-sdfg> spec

rules

  // Extract all scope graph assertions
  extract-scopes = collect-om(?CNew(_))
  extract-edges  = collect-om(?CTellEdge(_, _, _))
  extract-decls  = collect-om(?CTellRel(_, _, _))

rules

  extract-spec-sdfg = collect-om(extract-rule-sdfg); flatten-list

  extract-rule-sdfg: Rule(name, head, body) -> sdfg-c*
    with sdfg-c* := <flatten-list> [<extract-head-sdfg> head, <extract-body-sdfg> body]

  extract-head-sdfg: C(c-id, args) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-p-arg(|c-id))> args

  extract-body-sdfg = collect-om(extract-constraint-sdfg)

  extract-constraint-sdfg: C(c-id, args, _) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-p-arg(|c-id))> args

  /* extract-constraint-sdfg: CNew(var) -> sdfg-c*
    with sdfg-c* := [ DEdge(Variable(var), Variable(<term-to-var()> var)) ] */

  /* extract-constraint-sdfg: CTellEdge(src, lbl, tgt) -> sdfg-c*
    with sdfg-c* := [ DEdge(Variable(<term-to-var()> src), src)
                    , DEdge(Variable(<term-to-var()> tgt), tgt)] */

  extract-constraint-sdfg: CTellRel(rel, args, _) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-r-arg(|rel))> args

  // FIXME: How about constraints like `MOD(s1) == MOD(s2)`?
  extract-constraint-sdfg: CEqual(v1@Var(_), v2@Var(_), _) -> sdfg-c*
    where <sdfg-is-scope> v1
    with  <sdfg-is-scope> v2
        ; sdfg-c* := [UEdge(Variable(v1), Variable(v2))]

  extract-terms-sdfg(mk-arg) = map-with-index(extract-term-sdfg(mk-arg)); flatten-list

  extract-term-sdfg(mk-arg): (i, v@Var(_)) -> [UEdge(Variable(v), <mk-arg> i)]
    where(<sdfg-is-scope> v)

  extract-term-sdfg(mk-arg): (i, v@List(ts)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(\_ -> <mk-arg> i \)> ts

  extract-term-sdfg(mk-arg): (i, v@ListTail(ts, _)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(\_ -> <mk-arg> i \)> ts

  extract-term-sdfg(mk-arg): (i, v@Tuple(ts)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-c-arg(|""))> ts

  extract-term-sdfg(mk-arg): (i, v@As(_, t)) -> sdfg-c*
    with sdfg-c* := <extract-term-sdfg(mk-arg)> (i, t)

  extract-term-sdfg(mk-arg): (i, v@Ascribe(t, _)) -> sdfg-c*
    with sdfg-c* := <extract-term-sdfg(mk-arg)> (i, t)

  extract-term-sdfg(mk-arg): (i, v@Op(c, ts)) -> sdfg-c*
    with sdfg-c* := <extract-terms-sdfg(mk-c-arg(|c))> ts

  extract-term-sdfg(mk-arg): t -> []

rules

  mk-c-arg(|c-id): i -> CArg(c-id, i)
  mk-p-arg(|c-id): i -> PArg(c-id, i)
  mk-r-arg(|r-id): i -> RArg(r-id, i)

  sdfg-is-scope = get-annos; fetch-elem(?OfSort(<id>)); debug; ?SCOPE()
